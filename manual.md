The Ninja build system
----------------------

v1.10.2, Nov 2020

----

* [はじめに](#introduction)
  * [哲学的概要](#philosophical-overview)
  * [設計目標](#design-goals)
  * [比較して作る](#comparison-to-Make)
* [プロジェクトにNinjaを使う](#using-ninja-for-your-project)
  * [Ninjaの実行](#running-ninja)
  * [環境変数](#environmentvariables)
  * [追加ツール](#extra-tools)
* [独自のNinjaファイルの作成](#writing-your-own-ninja-files)
  * [概念図](#conceptual-overview)
  * [構文例](#syntax-example)
  * [変数](#variables)
  * [ルール](#rules)
  * [ビルドステートメント](#build-statements)
  * [コードから忍者ファイルを生成する](#generating-ninja-files-from-code)
* [詳細はこちら](#more-details)
  * [phonyルール](#the-phony-rule)
  * [デフォルトのターゲットステートメント](#default-target-statements)
  * [Ninjaのログ](#the-ninja-log)
  * [バージョンの互換性](#version-compatibility)
  * [C/C++ヘッダーの依存関係](#c/c++-header-dependencies)
	* [depfile](#depfile)
	* [deps](#deps)
  * [Pools](#pools)
* [Ninjaファイルリファレンス](#ninja-file-reference)
  * [字句構文](#lexical-syntax)
  * [トップレベルの変数](#top-level-variables)
  * [ルール変数](#rule-variables)
	* [コマンド変数の解釈](#interpretation-of-the-command-variable)
  * [ビルドアウトプット](#build-outputs)
  * [依存関係の構築](#build-dependencies)
  * [可変膨張](#variable-expansion)
  * [評価とスコーピング](#evaluation-and-scoping)
* [ダイナミック・デペンデンシー](#dynamic-dependencies)
  * [Dyndepファイルリファレンス](#dyndep-file-reference)
  * [ディンデップの例](#dyndep-examples)
	* [Fortranモジュール](#fortran-modules)
	* [Tarballの取り出し](#tarball-extraction)

------

# <a id="introduction">はじめに</a>

Ninjaはもう一つのビルドシステムです。ファイルの相互依存関係（一般的にはソースコードと出力される実行ファイル）を入力として受け取り、それらを迅速に構築するように編成します。

多くのビルドシステムが存在する中で、Ninjaはその一角を担っています。Ninjaの特徴的な目標は高速であることです。これは、私がChromiumブラウザプロジェクトに携わっていたことから生まれたものです。[Chromiumブラウザプロジェクト](http://neugierig.org/software/chromium/notes/2011/02/ninja.html)には3万以上のソースファイルがあり、他のビルドシステム（カスタムの非再帰的Makefileから構築されたものを含む）では、1つのファイルを変更してからビルドを開始するまでに10秒かかります。Ninjaは1秒以下です。

## <a id="philosophical-overview">哲学的概要</a>

他のビルドシステムが高レベル言語であるのに対し、Ninjaはアセンブラを目指しています。

ビルドシステムは、決定を下す必要があると遅くなります。編集-コンパイルのサイクルにいるときは、できるだけ速くしたいものです。ビルドシステムには、何をすぐに構築する必要があるかを把握するために、必要最小限の作業をさせたいものです。

Ninjaは、任意の依存関係グラフを記述するために必要な最低限の機能を備えています。構文がないため、複雑な決定を表現することはできません。

その代わりに、Ninjaは入力ファイルを生成する別のプログラムと一緒に使うことを想定しています。ジェネレータープログラム（autotoolsプロジェクトにある./configureのようなもの）は、システムの依存関係を分析し、できるだけ多くの決定を前もって行うことで、インクリメンタルなビルドを高速に保つことができます。オートツールだけでなく、「どのコンパイラフラグを使うか」「デバッグモードとリリースモードのどちらのバイナリをビルドするか」といったビルド時の判断も、.ninjaファイルジェネレータに属します。

## <a id="design-goals">設計目標</a>

ここでは、Ninjaのデザイン目標を紹介します:<br>

* 大規模なプロジェクトでも、非常に高速な（つまり瞬時の）インクリメンタル・ビルドを実現します。
* コードをどのようにビルドするかというポリシーはほとんどありません。プロジェクトや上位のビルドシステムによって、コードをどのようにビルドすべきかについて異なる意見があります。たとえば、ビルドされたオブジェクトはソースと一緒に置いておくべきなのか、それともすべてのビルド出力は別のディレクトリに置くべきなのか。例えば、ビルドされたオブジェクトはソースと一緒に置くべきなのか、それともビルド出力はすべて別のディレクトリに置くべきなのか、プロジェクトの配布可能なパッケージをビルドする「パッケージ」ルールはあるのか？結果的に冗長になったとしても、どちらかを選択するのではなく、どちらも実装できるようにすることで、これらの決定を回避することができます。
* 依存関係を正確に把握し、Makefileでは難しい特定の状況（例えば、出力を生成するためのコマンドラインに暗黙の依存関係が必要であったり、C言語のソースコードをビルドするためにgccの-Mフラグを使ってヘッダーの依存関係を確認する必要があったり）に対応します。
* 利便性とスピードが相反する場合は、スピードを優先します。

いくつかの明確な非目標:<br>

* ビルドファイルを手で書くための便利な構文です。あなたは別のプログラムを使ってninjaファイルを生成するべきです。このようにして、多くの方針決定を回避することができるのです。
* 組み込みルール。例えば、C言語のコードをコンパイルするためのルールはありません。
* ビルド時のカスタマイズを行います。オプションは、ninjaファイルを生成するプログラムに属します。
* 条件式や検索パスなどのビルドタイムの意思決定能力。意思決定に時間がかかる

つまり、Ninjaが他のビルドシステムよりも速いのは、非常にシンプルだからなのです。プロジェクトの.ninjaファイルを作成する際には、Ninjaに何をすべきかを正確に伝える必要があります。

## <a id="comparison-to-Make">比較して作る</a>

Ninjaは、Makeに最も近い精神と機能を持ち、ファイルのタイムスタンプ間の単純な依存関係に依存しています。

しかし、基本的には、makeには多くの機能があります。接尾辞のルール、関数、ソースをビルドする際にRCSファイルを検索するなどの組み込みルールなどです。Makeの言語は、人間が書くことを前提に設計されています。多くのプロジェクトでは、ビルドに関する問題をmakeだけで解決しています。

対照的に、Ninjaにはほとんど機能がありません。ビルドを正しく行うために必要な機能だけを備え、複雑な作業はNinjaの入力ファイルの生成に任されています。Ninjaはそれだけではほとんどのプロジェクトで役に立ちそうにありません。

ここでは、NinjaがMakeに追加する機能をいくつか紹介します。(これらの機能は、より複雑なMakefileを使って実装できることが多いのですが、Make自体の一部ではありません)。

* Ninjaは、ビルド時に余分な依存関係を発見するための特別なサポートを備えており、C/C++コードの[ヘッダー依存関係](#c/c++-header-dependencies)を簡単に修正することができます
* 1つのビルドエッジが複数の出力を持つことがあります
* 出力は、生成に使われたコマンドラインに暗黙のうちに依存しています。つまり、コンパイルフラグなどを変更すると、出力が再構築されます
* 出力ディレクトリは、それに依存するコマンドを実行する前に、常に暗黙的に作成されます
* ルールは、実行されるコマンドの短い説明を提供することができるので、ビルド中に長いコマンドラインの代わりに`CC foo.o`などを表示することができます
* ビルドは常に並列で実行され、デフォルトではシステムのCPU数に基づいて実行されます。ビルドの依存関係が不明確だと、正しくないビルドが行われます
* コマンド出力は常にバッファリングされます。つまり、並行して実行されているコマンドの出力が干渉することはなく、コマンドが失敗した場合には、失敗したコマンドラインの隣に失敗したコマンドの出力を表示することができます

----

# <a id="using-ninja-for-your-project">プロジェクトにNinjaを使う</a>

Ninjaは現在、Unix系システムとWindowsで動作します。最もテストされているのはLinuxですが、Mac OS XやFreeBSDでも問題なく動作しており、パフォーマンスも最高です。

プロジェクトの規模が小さければ、Ninjaのスピードへの影響はほとんど気にならないでしょう。(しかし、小さなプロジェクトであっても、Ninjaの限られた構文によって、よりシンプルなビルドルールが適用され、結果的にビルドが速くなることもあります)。別の言い方をすれば、もしあなたがプロジェクトの編集・コンパイルサイクルタイムに満足しているなら、Ninjaは役に立たないということです。

Ninjaよりも使い勝手や機能が充実しているビルドシステムは他にもたくさんあります。おすすめポイント：Ninjaの作者は、[tupのビルドシステム](http://gittup.org/tup/)がNinjaのデザインに影響を与えていると考えており、[redo](http://gittup.org/tup/)のデザインはかなり賢いと思っています。

Ninjaの利点は、よりスマートなメタビルドシステムと組み合わせて使うことです。

[gn](https://gn.googlesource.com/gn/)
:  Google Chromeとその関連プロジェクト（v8、node.js）、およびGoogle Fuchsiaのビルドファイルを生成するために使用されるメタビルドシステムです

[CMake](https://cmake.org/)
:  広く使われているメタビルドシステムで、CMakeバージョン2.8.8以降、LinuxでNinjaファイルを生成することができます。新しいバージョンのCMakeでは、WindowsやMac OS XでのNinjaファイルの生成がサポートされている。

[others](https://github.com/ninja-build/ninja/wiki/List-of-generators-producing-ninja-build-files)
:  Ninjaはpremakeのような他のメタビルドソフトウェアに完璧にフィットするはずです。もしこの作業をしたら、ぜひ教えてください。

## <a id="running-ninja">Ninjaの実行</a>

`ninja`を実行。デフォルトでは、カレントディレクトリにある `build.ninja` というファイルを探し、古くなったターゲットをすべてビルドします。ビルドするターゲット（ファイル）をコマンドライン引数で指定できます。

また、コマンドラインで指定したソースを含むルールの最初の出力としてターゲットを指定するための特別な構文`target`もあります。例えば、`target` を `foo.c` と指定すると、`foo.o` がビルドされます (ビルドファイルにこれらのターゲットがあると仮定して)。

`ninja -h`はヘルプ出力を表示します。`ninja -C build -j 20`はビルドディレクトリに移動し、20個のビルドコマンドを並列に実行します。例えば`ninja -C build -j 20`は build ディレクトリに移動し、20 個の build コマンドを並列に実行します (ただし、Ninja はデフォルトでコマンドを並列に実行するので、通常は`-j`を渡す必要はありません)。

## <a id="environmentvariables">環境変数</a>

Ninjaは、その動作を制御するために1つの環境変数をサポートしています。`NINJA_STATUS`は、実行されるルールの前に表示される進捗状況です。

いくつかのプレースホルダーが用意されています:

%s
:  開始されたエッジの数です。

%t
:  ビルドを完了させるために実行しなければならないエッジの総数です。

%p
:  起動したエッジの割合です。

%r
:  現在実行中のエッジの数です。

%u
:  開始する残りのエッジの数です。

%f
:  完成したエッジの数です。

%o
:  1秒あたりの完成したエッジの全体的な速度

%e
:  秒単位の経過時間。  （Ninja 1.2以降で利用可能です。）

%%
:  プレーンな`%`文字。

デフォルトの進捗状況は `"[%f/%t]"` です (ビルドルールと区別するために最後にスペースを入れていることに注意してください)。進捗状況の別の例としては、`"[%u/%r/%f]"`が考えられます。

## <a id="extra-tools">追加ツール</a>

Ninjaのコマンドラインにある-tフラグは、Ninjaの開発中に便利だと感じたいくつかのツールを実行します。現在のツールは以下の通りです:

query
:  与えられたターゲットの入力と出力をダンプします。

browse
:  Webブラウザで依存関係グラフを閲覧することができます。ファイルをクリックすると、そのファイルにフォーカスし、入力と出力を表示します。この機能を利用するには、Pythonのインストールが必要です。デフォルトでは、ポート8000が使用され、Webブラウザが開かれます。これは以下のように変更できます。
```
ninja -t browse --port=8000 --no-browser mytarget
```

graph
:  自動グラフレイアウトツール`graphviz`が使用する構文でファイルを出力します。のように使います:
```
ninja -t graph mytarget | dot -Tpng -ograph.png
```
Ninjaのソースツリーでは、`ninja graph.png`がNinja自身のイメージを生成します。ターゲットが指定されていない場合は、すべてのルートターゲットのグラフを生成します。

targets
:  ターゲットのリストをルール別または深度別に出力する。`ninja -t targets rule name`のように使うと、与えられたルールを使ってビルドされたターゲットのリストを表示する。ルールが与えられていない場合は、ソースファイル(グラフの葉)を表示します。`ninja -t targets depth digit` のように使うと、ルートターゲット（出力のないターゲット）から順にターゲットのリストを表示します。インデントは依存関係を示すのに使われる。深さが 0 の場合、すべてのターゲットを表示します。引数が与えられない場合、`ninja -t targets`の深さは 1 とみなされる。このモードでは、ターゲットは複数回リストアップされます。`ninja -t targets all`のように使うと、利用可能なすべてのターゲットをインデントなしで表示し、 depth モードよりも高速に表示することができる。


commands
:  ターゲットのリストが与えられた場合、すべての出力ファイルが古くなっていると仮定して、それらのターゲットを再構築するために使用される可能性のあるコマンドのリストを表示します。

clean
:  ビルドされたファイルを削除します。デフォルトでは、ジェネレーターが作成したものを除くすべてのビルドファイルを削除します。g フラグを追加すると、ジェネレーターによって作成されたビルドされたファイルも削除されます（[ジェネレーター属性のルール・リファレンス](#rule-variables)を参照）。追加の引数はtargetsで、これは指定されたターゲットと、そのターゲットのためにビルドされたすべてのファイルを再帰的に削除します。<br>
`ninja -t clean -r rules`のように使うと、与えられたルールで作られたすべてのファイルを削除します。<br>
作成されたがグラフ内で参照されていないファイルは削除されません。このツールは、`-v`と`-n`オプションを考慮しています（`-n`は`-v`を暗示しています）。

cleandead
:  以前のビルドで生成されたファイルのうち、ビルドファイルに含まれなくなったファイルを削除します。Ninja 1.10以降で利用可能です。

compdb
:  ソースファイルの名前を最初の入力とするC言語のコンパイラルールと予想されるルールのリストが与えられると、Clang tooling interfaceで予想される[JSON形式](https://clang.llvm.org/docs/JSONCompilationDatabase.html)のコンパイルデータベースを標準出力に出力します。Ninja 1.2 から利用可能です。

deps
:  `.ninja_deps`ファイルに格納されているすべての依存関係を表示します。ターゲットが与えられた場合、そのターゲットの依存関係だけを表示します。Ninja 1.4 以降で利用可能です。

recompact
:  `.ninja_deps`ファイルを再圧縮します。Ninja 1.4 以降で利用可能です。

restat
:  .ninja_logファイルに記録されているすべてのファイル変更タイムスタンプを更新します。  Ninja 1.10以降で利用可能です。

rules
:  すべてのルールのリストを出力します (最終的には、ルールに説明があればその説明も)。これは、`ninja -t targets rule name`や`ninja -t compdb`にどのルール名を渡すかを知るために利用できる。

----

# <a id="writing-your-own-ninja-files">独自のNinjaファイルの作成</a>

このマニュアルの残りの部分は、メタビルドシステムの構築や新しい言語のサポートなど、自分でNinjaファイルを構築する場合にのみ役立ちます。

## <a id="conceptual-overview">概念図</a>

Ninjaは、ファイル間の依存関係のグラフを評価し、ファイルの修正時間から判断して、ビルドターゲットを最新の状態にするために必要なコマンドを実行します。Makeに慣れている方には、Ninjaはとても似ています。

ビルドファイル（デフォルト名：`build.ninja`）は、ルールのリスト（コンパイラの実行方法などの長いコマンドの短い名前）と、ルールを使ってファイルをビルドする方法（どのルールをどの入力に適用してどの出力を出すか）を示すビルドステートメントのリストを提供します。

概念的には、`build`ステートメントはプロジェクトの依存関係グラフを記述し、`rule`ステートメントはグラフの特定のエッジに沿ってファイルを生成する方法を記述します。

## <a id="syntax-example">構文例</a>

ここでは、基本的な`.ninja`ファイルを使って、ほとんどの構文を説明します。以下のセクションでは、このファイルを例にして説明します。

```
cflags = -Wall

rule cc
  command = gcc $cflags -c $in -o $out

build foo.o: cc foo.c
```

## <a id="variables">変数</a>

ビルドファイルの可読性（デバッグ性）を保つために、手書きで書くのが便利であるという非目的にもかかわらず、Ninjaは文字列の再利用可能な短い名前を宣言することをサポートしています。以下のような宣言です。

```
cflags = -g
```

等号の右側で使用でき、次のようにドル記号で逆参照します:

```
rule cc
  command = gcc $cflags -c $in -o $out
```

変数は、`${in}`のような中括弧を使用して参照することもできます。

変数は「バインディング」と呼ばれる方がよいかもしれません。特定の変数は変更できず、シャドウされるだけです。シャドウイングがどのように機能するかについては、このドキュメントの後半で詳しく説明します。

## <a id="rules">ルール</a>

ルールは、コマンドラインの短い名前を宣言します。  これらは、`rule`キーワードとルールの名前で構成される行で始まります。  次に、インデントされた`variable = value`の行のセットが続きます。

## <a id="build-statements">ビルドステートメント</a>

ビルドステートメントは、入力ファイルと出力ファイルの間の関係を宣言します。  それらは`build`キーワードで始まり、`build output：rulename inputs`という形式になっています。  このような宣言は、すべての出力ファイルが入力ファイルから派生していることを示しています。  出力ファイルが欠落している場合、または入力が変更された場合、Ninjaはルールを実行して出力を再生成します。

上記の基本的な例では、`cc`ルールを使用して`foo.o`をビルドする方法について説明しています。

`build`ブロックのスコープ（関連する`rule`の評価を含む）では、変数`$in`は入力のリストであり、変数`$out`は出力のリストです。

ビルドステートメントの後には、ルールのように`key = value`のペアをインデントして記述することができます。これらの変数は、コマンド内の変数を評価する際に、任意の変数の影になります。例えば

```
cflags = -Wall -Werror
rule cc
  command = gcc $cflags -c $in -o $out

# 指定されていない場合、ビルドは外側の$cflagsを取得します。
build foo.o: cc foo.c

# そのため、特定のビルド用に cflags のような変数をシャドーイングすることができます。
build special.o: cc special.c
  cflags = -Wall

# この変数は、special.oの範囲でのみシャドウイングされていました。
# 後続のビルドラインでは、外側（オリジナル）の cflags が使用されます。
build bar.o: cc bar.c
```

スコーピングの仕組みについては、[参考文献](#evaluation-and-scoping)を参照してください。

ビルドステートメントからルールに渡されるより複雑な情報が必要な場合（例えば、ルールが「最初の入力のファイル拡張子」を必要とする場合）は、上記の`cflags`の渡し方のように、追加の変数として渡します。

ビルドステートメントの出力としてトップレベルのNinjaファイルが指定され、それが古くなっている場合、Ninjaはユーザーが要求したターゲットをビルドする前に、そのファイルをリビルドして再読み込みします。

## <a id="generating-ninja-files-from-code">コードから忍者ファイルを生成する</a>

Ninja ディストリビューションに含まれる`misc/ninja_syntax.py`は、Ninjaファイルの生成を容易にする小さな Python モジュールです。`ninja.rule(name='foo', command='bar', depfile='$out.d')`のような Python 呼び出しを行うと、適切な構文を生成してくれます。便利であれば、プロジェクトのビルドシステムに自由にインライン化してください。

----

# <a id="more-details">詳細はこちら</a>

## <a id="the-phony-rule">phonyルール</a>

特別なルール名`phony`を使って、他のターゲットのエイリアスを作成することができます。例えば、以下のようになります。

```
build foo: phony some/file/in/a/faraway/subdir/foo
```

これにより、`ninja foo`は長いパスを構築します。意味的には`phony`ルールは`command`が何もしないプレーンなルールと同じですが、 phony ルールは実行時に表示されず、ログにも記録されず（下記参照）、 ビルドプロセスの一部として表示されるコマンド数にも寄与しないという点で 特別に扱われます。

`phony`は、ビルド時に存在しない可能性のあるファイルのダミーターゲットを作成するためにも使用できます。依存関係がない状態で phony build statement を記述すると、ターゲットが存在しない場合は古いものとみなされます。phony build statementがない場合、ファイルが存在せず、かつビルドに必要なファイルであれば、Ninjaはエラーを報告します。

リビルドしないルールを作成するには、入力のないビルドルールを使用します。

```
rule touch
  command = touch $out
build file_that_always_exists.dummy: touch
build dummy_target_to_follow_a_pattern: phony file_that_always_exists.dummy
```

## <a id="default-target-statements">デフォルトのターゲットステートメント</a>

デフォルトでは、コマンドラインでターゲットが指定されていない場合、Ninjaは、他の場所で入力として指定されていないすべての出力をビルドします。この動作を無効にするには、default targetステートメントを使用します。default targetステートメントは、コマンドラインでターゲットが指定されていない場合、Ninjaは指定された出力ファイルのサブセットのみをビルドします。

デフォルトターゲットステートメントは、defaultキーワードで始まり、default targetsというフォーマットを持ちます。default targetステートメントは、ターゲットを出力ファイルとして宣言するbuildステートメントの後に記述する必要があります。これらのステートメントは累積的であり、複数のステートメントを使用してデフォルトターゲットのリストを拡張することができます。例えば、以下のようになります:

```
default foo bar
default baz
```

これにより、Ninjaはデフォルトで`foo`、`bar`、`baz`ターゲットをビルドします。

## <a id="the-ninja-log">Ninjaのログ</a>

ビルドされた各ファイルには、ビルドに使用されたコマンドのログが記録されます。このログを利用することで、既存の出力がビルドファイルで指定されたコマンドラインとは異なるコマンドラインでビルドされた場合（コマンドラインが変更された場合）、Ninjaはそのファイルの再構築を知ることができます。

ログファイルはビルドルートの`.ninja_log`というファイルに保存されます。一番外側のスコープで`builddir`という変数を指定すると、`.ninja_log`はそのディレクトリに保存されます。

## <a id="version-compatibility">バージョンの互換性</a>

*Ninja 1.2から使用可能です。*

Ninja のバージョンラベルは標準的な major.minor.patch 形式に従っており、後方互換性のない構文や動作の変更にはメジャーバージョンが、新しい動作にはマイナーバージョンが増やされます。`build.ninja` では `ninja_required_version` という変数を宣言して、生成されたファイルを使用するために必要な最低限の Ninja のバージョンを表明することができます。例えば

ビルドファイルはNinja1.1で導入された機能（おそらくプール構文）に依存しており、ビルドにはNinja1.1以降を使用する必要があることを宣言します。  他のNinja変数とは異なり、このバージョン要件は、変数が解析中に検出されるとすぐにチェックされるため、ビルドファイルの先頭に配置することをお勧めします。

Ninjaのメジャーバージョンと`ninja_required_version`が一致しない場合、Ninjaは常に警告します。  メジャーバージョンの変更はまだ行われていないため、どのような動作が必要になるかを予測することは困難です。

## <a id="c/c++-header-dependencies">C/C++ヘッダーの依存関係</a>

C/C++ヘッダーの依存関係（または同様の方法で動作する他のビルド依存関係）を正しく理解するために、Ninjaにはいくつかの追加機能があります。

ヘッダーの問題点は、あるソースファイルが依存しているファイルの完全なリストが、コンパイラによってしか発見できないことです。プリプロセッサの定義やインクルードパスが異なると、使用されるファイルも異なります。コンパイラの中には、ビルド中にこの情報を発信するものがあり、Ninjaはそれを利用して依存関係を完璧にすることができます。

考えてみてください。ファイルが一度もコンパイルされていない場合は、とにかくビルドしなければならず、副作用としてヘッダーの依存関係が発生します。ファイルが後に修正された場合（依存するヘッダが変更された場合も含む）、その修正によって再構築が行われ、依存関係が最新の状態に保たれます。

これらの特別な依存関係を読み込む際、Ninjaは暗黙のうちに追加のビルドエッジを追加し、リストアップされた依存関係が欠けていてもエラーにならないようにします。これにより、ヘッダファイルを削除して再構築しても、入力の欠落によりビルドが中断することはありません。

### <a id="depfile">depfile</a>

`gcc`(および`clang`などの他のコンパイラ) は、Makefile の構文で依存関係の情報を出すことをサポートしています。(`gcc`に限らず、この形式で依存関係を書けるコマンドはすべて使用できます)。

この情報をNinjaに取り込むには協力が必要です。Ninja側では、`build`の`depfile`属性が、このデータが書き込まれているパスを指し示す必要があります。(Ninjaは、コンパイラが発するMakefile構文の限られたサブセットしかサポートしていない)。そして、コマンドは依存関係を`depfile`のパスに書き込むことを知っていなければなりません。以下の例のように使います。

```
rule cc
  depfile = $out.d
  command = gcc -MD -MF $out.d [other gcc flags here]
```

`gcc`の`-MD`フラグは、ヘッダの依存関係を出力するように指示し、`-MF`フラグは、どこに記述するかを指示します。

### <a id="deps">deps</a>

*(Ninja 1.3から利用可能)*

大規模なプロジェクトでは（特にファイルシステムが遅いWindowsでは）、起動時にこれらの依存関係のあるファイルを読み込むのに時間がかかることがわかりました。

Ninja 1.3では、依存関係が生成された直後にそれを処理し、同じ情報をコンパクトにまとめてNinja内部のデータベースに保存することができます。

Ninjaでは、この処理を2つの形でサポートしています。

1. `deps = gcc`は、ツールが`gcc`スタイルの依存関係をMakefileの形で出力することを指定します。上記の例にこれを追加すると、Ninjaはコンパイル終了後すぐに`depfile`を処理し、その後（一時的にしか使われない）.dファイルを削除します。
2. `deps = msvc`は、Visual Studio のコンパイラの [/showIncludes フラグ](https://msdn.microsoft.com/en-us/library/hdkef6tk(v=vs.90).aspx)で生成される形式で、ツールがヘッダの依存関係を出力することを指定します。簡単に言うと、このツールは特別にフォーマットされた行を標準出力に出力します。Ninja は、表示された出力からこれらの行をフィルタリングします。`depfile` 属性は必要ありませんが、ヘッダーファイルのパスの前にローカライズされた文字列を指定します。例えば、 `msvc_deps_prefix = Note: including file:`を含む English Visual Studio (デフォルト)のようになります。グローバルに定義する必要があります。

```
msvc_deps_prefix = Note: including file:
rule cc
  deps = msvc
  command = cl /showIncludes -c $in /Fo$out
```

インクルード・ディレクトリ・ディレクティブが絶対パスを使用している場合、depfileは相対パスと絶対パスが混在する結果になるかもしれません。他のビルドルールで使われるパスは正確に一致する必要があります。したがって、このような場合には相対パスを使用することをお勧めします。

## <a id="pools">Pools</a>

*Ninja 1.1から使用可能です。*

プールでは、1つまたは複数のルールまたはエッジに、デフォルトの並列処理よりも厳しく制限された有限個の同時実行ジョブを割り当てることができます。

これは、例えば、高価なルール（巨大な実行ファイルのリンクステップなど）を制限したり、同時実行時にパフォーマンスが低下することがわかっている特定のビルドステートメントを制限したりするのに役立ちます。

各プールには、ビルドファイルで指定される`depth`変数があります。プールは、ルールまたはビルドステートメントで、`pool`変数を使って参照されます。

どのようなプールを指定しても、ninjaはデフォルトの並列度や、コマンドライン（-j付き）で指定したジョブ数よりも多くの同時実行ジョブを実行することはありません。

```
# 一度に4つ以上のリンクを貼ることはできません。
pool link_pool
  depth = 4

# 重いものは一度に1個までとします。
pool heavy_object_pool
  depth = 1

rule link
  ...
  pool = link_pool

rule cc
  ...

# ここではlink_poolを使用します。4つのリンクのみが同時に実行されます。
build foo.exe: link input.obj

# ビルドステートメントは、空のプールを設定することで、そのルールのプールから除外することができます。
# これにより、ビルドステートメントは、無限の深さを持つデフォルトプールに戻ることになります。
build other.exe: link input.obj
  pool =

# ビルドステートメントでは、プールを直接指定することができます。
# 一度に実行されるのは、これらのビルドのうち1つだけです。
build heavy_object1.obj: cc heavy_obj1.cc
  pool = heavy_object_pool
build heavy_object2.obj: cc heavy_obj2.cc
  pool = heavy_object_pool
```

`console` プール

*Ninja 1.5から利用可能です。*

深さ1の`console`という名前の事前定義されたプールが存在します。これには、プール内のすべてのタスクが、通常はユーザーのコンソールに接続されているNinjaに提供される標準入力、出力、およびエラーストリームに直接アクセスできるという特別なプロパティがあります。 （そのため名前が付けられています）が、リダイレクトされる可能性があります。  これは、コンソールでステータスの更新を生成するインタラクティブなタスクや長時間実行されるタスク（テストスイートなど）に役立ちます。

コンソールプール内のタスクが実行されている間、Ninjaの通常の出力（進行状況や同時実行タスクからの出力など）は、タスクが完了するまでバッファリングされます。

----

# <a id="ninja-file-reference">Ninjaファイルリファレンス</a>

ファイルは、一連の宣言で構成されています。宣言は次のいずれかです。

1. ルール宣言は、`rule rulename`で始まり、変数を定義するインデントされた一連の行があります。
2. ビルドエッジとは、`build output1 output2: rulename input1 input2` のようなものです。暗黙的な依存関係は、｜dependency1 dependency2 で末尾に付加することができます。 Order-onlyの依存関係は、 || dependency1 dependency2 で末尾に付けることができます。([依存関係の種類に関するリファレンス](#build-dependencies)を参照してください)。<br><br>
暗黙的な出力 (Ninja 1.7 以降で利用可能) は、 `| output1 output2` で `:` の前に追加することができ、`$out` には表示されません。([出力タイプに関するリファレンス](#build-outputs)を参照してください。)<br><br>
3. `variable = value`のような変数宣言。
4. デフォルトのターゲットステートメントで、`default target1 target2`のようになります。
5. `subninja path`や`include path`のような、より多くのファイルへの参照。これらの違いについては、後述のスコーピングの項で説明します。
6. `pool poolname`のようなプール宣言です。プールについては、[プール](#pools)の項で説明します。

## <a id="lexical-syntax">字句構文</a>

Ninjaは、Ninjaが気にするバイト（パスのスラッシュなど）がASCIIである限り、ほとんどの場合、エンコーディングに依存しません。つまり、UTF-8やISO-8859-1の入力ファイルは動作するはずです。

コメントは#で始まり、行の最後まで続きます。

改行は重要です。`build foo bar`のようなステートメントは、スペースで区切られたトークンの集合で、最後は改行で終わります。トークン内の改行とスペースはエスケープしなければなりません。

エスケープ文字は`$`のみで、以下のような動作をします。

$の後に改行を入れる
:  改行をエスケープする（現在の行を改行して続ける）。

$の後にテキストが続く
:  変数の参照。

${varname}
:  varname の代替構文です。

$の後にスペースを入れる
:  スペース。(これは、パスのリストの中で、スペースでファイル名を区切る場合にのみ必要です。以下を参照してください)。

$:
:  コロン。(これはビルドラインでのみ必要です。コロンがないと出力のリストが終了してしまいます) 

$$
:  リテラルの`$`。

build文やdefault文は、まずスペースで区切られたファイル名のリストとして解析され、次に各ファイル名が展開されます。つまり、変数の中のスペースは、展開されたファイル名の中のスペースになります。

```
spaced = foo bar
build $spaced/baz other$ file: ...
# 上記のビルドラインには2つの出力があります。"foo bar/baz"と "other file"です。
```

`name = value`ステートメントでは、値の先頭のホワイトスペースは常に取り除かれます。また、改行後の行頭の空白も除去されます。

```
two_words_with_one_space = foo $
    bar
one_word_with_no_space = foo$
    bar
```

その他のホワイトスペースは、行の先頭にある場合にのみ意味を持ちます。行が前の行よりもインデントされている場合、その行は親のスコープの一部とみなされ、前の行よりもインデントされていない場合、前のスコープを閉じます。

## <a id="top-level-variables">トップレベルの変数</a>

一番外側のファイルスコープで宣言された2つの変数は重要です。

builddir
:  実行するコマンドラインを指定します。各`rule`では、1つの`command`宣言しかできません。複数のコマンドを引用して実行する方法については、次のセクションを参照してください。

ninja_required_version
:  ビルドを正しく処理するために必要なNinjaの最小バージョンです。[バージョニングについての説明](#version-compatibility)を参照してください。

## <a id="rule-variables">ルール変数</a>

`rule`ブロックには、ルールの処理に影響を与える`key = value`の宣言のリストが含まれています。ここでは、特別なキーの全リストを紹介します。

command(必須)
:  実行するコマンドラインを指定します。各`rule`では、1つの`command`宣言しかできません。複数のコマンドを引用して実行する方法については、次のセクションを参照してください。

depfile
:  追加の暗黙の依存関係を含むオプションの`Makefile`へのパスです（[依存関係の種類に関するリファレンス](#build-dependencies)を参照してください）。これは明示的にC/C++ヘッダーの依存関係をサポートするためのものです。[詳しい説明はこちら](#c/c++-header-dependencies)をご覧ください。

deps
:  (Ninja 1.3 以降で利用可能です。) 存在する場合、特別な依存性処理を指定するには gcc または msvc のいずれかでなければなりません。[詳しい説明](#c/c++-header-dependencies)を参照してください。生成されたデータベースは`.ninja_deps`として builddir に保存されますが、[builddirについての議論](#top-level-variables)を参照してください。

msvc_deps_prefix
:  (Ninja 1.5 以降で利用可能です。) msvc の /showIncludes 出力から取り除かれるべき文字列を定義します。`deps = msvc`で、英語版の Visual Studio を使用していない場合にのみ必要です。

description
:  コマンドの簡単な説明。実行中にコマンドをきれいに印刷するために使用されます。  -vフラグは、コマンド全体を出力するか、その説明を出力するかを制御します。  コマンドが失敗した場合、コマンドの出力の前に常に完全なコマンドラインが出力されます。

dyndep
:  （Ninja 1.10以降で使用可能です。）ビルドステートメントでのみ使用されます。  存在する場合は、ビルドステートメント入力の1つに名前を付ける必要があります。  動的に検出された依存関係情報がファイルからロードされます。  詳細については、動的依存関係のセクションを参照してください。

generator
:  generatorが存在する場合、このルールがジェネレータープログラムの再起動に使用されることを指定します。`generator`ルールを使用して構築されたファイルは、2つの点で特別に扱われます。1つ目は、コマンドラインが変更されても再構築されないこと、2つ目は、デフォルトではクリーニングされないことです。

in
:  このルールを参照するビルドラインの入力として提供されるファイルのスペース区切りのリストで、コマンドに含まれる場合はシェル・クォートされます。(このファイル・リストのサブセットやバリエーションが必要な場合は、そのリストで新しい変数を作成し、代わりにそれを使用してください)。
このruleを参照するビルドラインへの入力として提供されるファイルのスペース区切りのリスト。コマンドに表示される場合はシェルで引用されます。  （`$in`は便宜上提供されています。このファイルのリストのサブセットまたはバリアントが必要な場合は、そのリストを使用して新しい変数を作成し、代わりにそれを使用してください。）

in_newline
:  `$in`と同じですが、複数の入力がスペースではなく改行で区切られている点が異なります。  （`$rspfile_content`で使用します。これは、入力の処理に固定サイズのバッファーを使用するMSVCリンカーのバグを回避します。）

out
:  この`rule`を参照するビルドラインの出力として提供されるファイルのスペースで区切られたリストで、コマンドに含まれている場合はシェルクオートで表示されます。

restat
:  `restat`が存在する場合、Ninja はコマンドの実行後にそのコマンドの出力を再設定します。コマンドが変更しなかった修正時間の各出力は、ビルドする必要がなかったかのように扱われます。これにより、出力の逆方向の依存関係が、保留中のビルドアクションのリストから削除されることがあります。

rspfile, rspfile_content
:  `rspfile, rspfile_content`存在する場合（両方）、Ninjaは指定されたコマンドの応答ファイルを使用します。つまり、コマンドを呼び出す前に選択した文字列（`rspfile_content`）を指定されたファイル（`rspfile`）に書き込み、コマンドが正常に実行された後にファイルを削除します。

これは、コマンドラインの最大長が制限されており、レスポンスファイルを使用しなければならないWindows OSの場合に特に有効です。

以下の例のように使用します:

```
rule link
  command = link.exe /OUT$out [usual link flags here] @$out.rsp
  rspfile = $out.rsp
  rspfile_content = $in

build myapp.exe: link a.obj b.obj [possibly many other .obj files]
```

### <a id="interpretation-of-the-command-variable">コマンド変数の解釈</a>

基本的に、コマンドラインの動作はUnixとWindowsでは異なります。

Unixでは、コマンドは引数の配列です。Ninja `command`変数は`sh -c`に直接渡され、`sh -c`はその文字列を解釈してargv配列にする役割を果たします。したがって、引用符の規則はシェルのものであり、複数のコマンドを連鎖させるための`&&`や、環境変数を設定するための`VAR=value cmd`など、通常のシェルの演算子をすべて使用することができます。

Windowsではコマンドは文字列なので、Ninjaは`command`文字列を直接`CreateProcess`に渡します。(単にコンパイラを実行するだけの一般的なケースでは、これはオーバーヘッドが少ないことを意味します)。その結果、引用規則は呼び出されたプログラムによって決定され、Windowsでは通常Cライブラリによって提供されます。コマンドをシェルで解釈する必要がある場合（複数のコマンドを連鎖させるための`&&`の使用など）は、コマンドの前に`cmd /c`を付けて、Windowsシェルを実行するようにしてください。Ninjaでは「invalid parameter」というエラーが出ることがありますが、これは通常、コマンドラインの長さを超えたことを示しています。

## <a id="build-outputs">ビルドアウトプット</a>

ビルドの出力には、微妙に異なる2種類のタイプがあります。

1. ビルド・ラインに記載されているような明示的な出力。これらは、ルールの`$out`変数として使用できます。<br>
これは、コンパイルコマンドのオブジェクトファイルなどに使用される標準的な出力形式です。
2. 暗黙的な出力は、ビルドラインの : の前に `| out1 out2 +`という構文で表示されます (Ninja 1.7 以降で使用可能)。意味は明示的な出力と同じですが、唯一の違いは、暗黙的な出力は`$out`変数に表示されないことです。<br>
これは、コマンドのコマンドラインに表示されない出力を表現するためのものです。

## <a id="build-dependencies">依存関係の構築</a>

ビルドの依存関係には3つのタイプがあり、微妙に異なります。

1. ビルドラインに記載されている明示的な依存関係。これらのファイルは、ルールの`$in`変数として使用できます。これらのファイルに変更があった場合、出力は再構築されます。これらのファイルがなく、Ninja がその構築方法を知らない場合、構築は中断されます。<br>
これは、コンパイルコマンドのソースファイルなどに使用される標準的な依存関係の形式です。
1. 暗黙の依存関係とは、ルールの`depfile`属性や、ビルド行の最後にある`| dep1 dep2` という構文から得られるものです。意味合いは明示的な依存関係と同じですが、唯一の違いは、暗黙的な依存関係は`$in`変数に表示されないことです。<br>
これは、コマンドのコマンドラインに表示されない依存関係を表現するためのものです。例えば、スクリプトを実行するルールの場合、スクリプトに変更があると出力が再構築されるため、スクリプト自体を暗黙の依存関係とする必要があります。<br>
1. ビルド行の最後に`｜｜ dep1 dep2`という構文で表されるオーダーオンリーの依存関係。これらが古くなった場合、それらがビルドされるまで出力は再構築されませんが、オーダーオンリー依存関係の変更だけでは出力が再構築されることはありません。<br>
Order-only dependencyは、ビルド時にのみ発見される依存関係をブートストラップするのに役立ちます。例えば、後続のコンパイルステップを開始する前にヘッダーファイルを生成する場合などです。(ヘッダがコンパイル時に使用されると、生成された依存関係ファイルが暗黙の依存関係を表現します)。

ファイルのパスはそのまま比較されます。つまり、同じファイルを指している絶対パスと相対パスは、Ninjaでは異なるものとみなされます。

## <a id="variable-expansion">可変膨張</a>

変数は、パス（`build`や`default`文）やname = value文の右端で展開されます。

`name = value`文が評価されると、その右辺は (以下のスコーピング・ルールに従って) すぐに展開され、それ以降`$name`は展開の結果としての静的な文字列に展開されます。値が二重に展開されるのを防ぐために、「ダブルエスケープ」が必要になることは決してありません。

すべての変数は、解析中に発生した時点で直ちに展開されますが、重要な例外があります。ルールブロック内の変数は、ルールが宣言された時点ではなく、`rule`が使用された時点で展開されます。次の例では、`demo` ルールが「this is a demo of bar」と表示されています。

```
rule demo
  command = echo "this is a demo of $foo"

build out: demo
  foo = bar
```

## <a id="evaluation-and-scoping">評価とスコーピング</a>

トップレベルの変数宣言は、それが出現するファイルにスコープされます。

また、ルールの宣言は、それが発生するファイルにスコープされます。*(Ninja 1.6以降で利用可能)*

別の `.ninja` ファイルをインクルードするために使われる `subninja` キーワードは、新しいスコープを導入します。インクルードされた `subninja` ファイルは、親ファイルの変数やルールを使用し、その値をファイルのスコープに反映させることができますが、親ファイルの変数の値には影響しません。

C言語の`#include`文のように、別の`.ninja`ファイルを現在のスコープに含めるには、`subninja`の代わりに`include`を使います。

`build`ブロックでインデントされた変数宣言は、その`build`ブロックにスコープされます。`build`ブロックで展開された変数（または`rule`が使用されている）の完全な検索順序は次のとおりです:

1. 特殊な組み込み変数（$in、$out）。
2. ビルドブロックからの`build`レベルの変数。
3. `rule`ブロックのルール・レベル変数 (例: `$command`)。(上記の展開に関する説明によると、これらは「遅れて」展開され、 `$in` のようなスコープ内バインディングを使用する可能性があることに注意してください)。
4. `build`ラインが入っていたファイルのファイルレベルの変数。
5. `subninja`キーワードでそのファイルを含めたファイルの変数。

----

# <a id="dynamic-dependencies">ダイナミック・デペンデンシー</a>

*Ninja 1.10から使用可能です。*

ユースケースによっては、最初の実行時に正しくビルドするために、ビルド中にソースファイルの内容から暗黙の依存関係情報を動的に発見する必要があります（例：Fortranモジュールの依存関係）。これは、正しく再構築するために2回目以降の実行時にのみ必要となる[ヘッダー依存関係](#c/c++-header-dependencies)とは異なります。ビルド・ステートメントは、ダイナミックな依存性情報をファイルから読み込む必要があることを指定するために、入力の1つにdyndepバインディングを指定することができます。例えば、以下のようになります:

```
build out: ... || foo
  dyndep = foo
build foo: ...
```

これは、ファイル `foo` が dyndep ファイルであることを指定しています。これは入力なので、`foo`がビルドされる前に`out`のビルド文が実行されることはありません。`foo`のビルドが完了すると、Ninjaはそれを読み込んで`out`のために動的に発見された依存関係情報をロードします。これには、追加の暗黙の入力や出力が含まれることがあります。Ninjaはそれに応じてビルドグラフを更新し、その情報が元々あったかのようにビルドを進めます。

## <a id="dyndep-file-reference">Dyndepファイルリファレンス</a>

dyndepのバインディングで指定されたファイルは、[ninjaのビルドファイル](#ninja-file-reference)と同じ[字句構文](#lexical-syntax)を使い、以下のようなレイアウトになっています。

1. `<major>[.<minor>][<suffix>]`形式のバージョン番号です:
```
ninja_dyndep_version = 1
```
現在、バージョン番号は常に`1`または`1.0`でなければなりませんが、任意のサフィックスを付けることができます。<br>
2. 形式の1つまたは複数のビルドステートメント:

```
build out | imp-outs... : dyndep | imp-ins...
```
すべてのステートメントは、正確に1つの明示的な出力を指定する必要があり、ルール名として`dyndep`を使用する必要があります。 `imp-outs...`および｜`imp-ins...`の部分はオプションです。
3. 各ビルドステートメントでのオプションのrestat[変数バインディング](#rule-variables)です。

dyndepファイル内のビルド文は、`dyndep`バインディングでdyndepファイルを名付ける[ninjaビルドファイル](#ninja-file-reference)内のビルド文と一対一に対応していなければならない。dyndepのビルド文を省略することはできず、余分なビルド文を指定することもできません。

## <a id="dyndep-examples">ディンデップの例</a>
### <a id="fortran-modules">Fortranモジュール</a>

モジュール `foo.mod` を提供する Fortran ソースファイル `foo.f90` (コンパイル時の暗黙の出力) と、そのモジュールを使用する別のソースファイル `bar.f90` (コンパイル時の暗黙の入力) を考えてみましょう。この暗黙の依存関係は、どちらかのソースをコンパイルする前に発見されなければなりません。それは、`bar.f90`が`foo.f90`より先にコンパイルされることがないように、また、`foo.mod`が変更されたときに`bar.f90`が再コンパイルされるようにするためです。これを実現するには次のようにします。

```
rule f95
  command = f95 -o $out -c $in
rule fscan
  command = fscan -o $out $in

build foobar.dd: fscan foo.f90 bar.f90

build foo.o: f95 foo.f90 || foobar.dd
  dyndep = foobar.dd
build bar.o: f95 bar.f90 || foobar.dd
  dyndep = foobar.dd
```

この例では、順序のみの依存関係により、どちらかのソースがコンパイルされる前に`foobar.dd`が生成されるようになっています。仮想的な`fscan`ツールは、ソースファイルをスキャンし、それぞれが同名の`.o`にコンパイルされると仮定して、`foobar.dd`を次のような内容で書き込みます。

```
ninja_dyndep_version = 1
build foo.o | foo.mod: dyndep
build bar.o: dyndep |  foo.mod
```

Ninja はこのファイルをロードして `foo.mod` を `foo.o` の暗黙の出力、`bar.o` の暗黙の入力として追加します。これにより、Fortran ソースは常に適切な順序でコンパイルされ、必要に応じて再コンパイルされます。

### <a id="tarball-extraction">Tarballの取り出し</a>

`foo.tar`というtarballを抽出したいとします。抽出時間を `foo.tar.stamp` ファイルで記録しておけば、tarball が変わっても抽出を繰り返すことができるが、出力のどれかが欠けていたら再抽出したいと思う。しかし、出力のリストはtarballの内容に依存するので、ninjaのビルドファイルに明示的に綴ることはできない。これを実現するには次のようにします。

```
rule untar
  command = tar xf $in && touch $out
rule scantar
  command = scantar --stamp=$stamp --dd=$out $in
build foo.tar.dd: scantar foo.tar
  stamp = foo.tar.stamp
build foo.tar.stamp: untar foo.tar || foo.tar.dd
  dyndep = foo.tar.dd
```

この例では、order-only dependencyによって、tarballが展開される前に `foo.tar.dd`がビルドされるようになっています。仮想的な `scantar`ツールは、`tar tf` などで tarball を読み、 `foo.tar.dd` を次のような内容で書き込みます。

```
ninja_dyndep_version = 1
build foo.tar.stamp | file1.txt file2.txt : dyndep
  restat = 1
```

Ninjaはこのファイルを読み込むことで、`foo.tar.stamp`の暗黙的な出力として`file1.txt`と`file2.txt`を追加し、`restat`用のビルド文をマークします。次回以降のビルドでは、暗黙の出力が欠落している場合、tarballは再度抽出されます。`restat`は、暗黙の出力が tarball自体よりも新しい修正時間を持っていないかもしれないという事実を許容するよう、Ninja に指示します (ビルドのたびに再抽出することを避けるため)。

